---
title: 'Laying out figures with ggplot2'
date: '02-12-2024'
categories: ['Example', 'ggplot2']
description: 'This is a test post. In this post, I try out different functionalities in the hope of making a template.'
execute:
  # eval	# Evaluate the code chunk (if false, just shows the code in the output)
  # echo 	# Include the source code in output
  output: true # 	Include the results of executing the code in the output (true, false, or asis to indicate that the output is raw markdown and should not have any of Quartoâ€™s standard enclosing markdown)
  message: false
  warning: false # Include warnings in the output
  error: false # Include errors in the output (note that this implies that errors executing code will not halt processing of the document).
  # include: # Catch all for preventing any output (code or results) from being included (e.g. include: false suppresses all output from the code block).
  # code-overflow: wrap
editor_options: 
  chunk_output_type: inline
knitr:
  opts_chunk: 
    fig.align: "center"
    fig-width: 8
    fig-asp: 0.75
    code-overflow: wrap
toc: true
---

# Setup

## Why?

::: ol
1.   Previously was using a combination of R, Powerpoint, and Latex to lay out figures.
2.   However, it was a very finicking process. If I'm going to be using Quarto/R for most things would be nice to do things all in one place.
3.   I really want to enable other students/academics to do things without reinventing the wheel.
:::

I like to use `pacman` (the package manager) because its function `p_load` acts like `library()` if the package is already installed and `install.packages()` if it isn't. You can also pass all your package names to it as a single vector. 

```{r setup, eval=FALSE}
#| collapse: true

install.packages("pacman", repos="https://cran.r-project.org", update = TRUE)

# Basic plotting packages
pacman::p_load("ggplot2", update = TRUE)

# All the packages we need for laying out plots
pacman::p_load("grid", "gridExtra", "gtable", "cowplot", "multipanelfigure", "egg", "patchwork", update = TRUE)

# Extra stuff
pacman::p_load("ggpubr", "ggplotify", "tidyverse", update = TRUE)
```

So these are the packages I want to compare. A lot of the inspiration for this work came from the `egg` vignettes ([here](https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html) and [here](https://cran.r-project.org/web/packages/egg/vignettes/Overview.html)), so make sure to check those out if you want further information. 

| Package | Version | Function(s) | Compatible with `ggsave()` | Alignment |
|------                 |------                                  |------                   |------ |------ |
| [r cookbook (`grid`)](http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/){.external target="_blank"}   | `r packageVersion("grid")`    | `multiplot`    | no    | no    |
| [`gridExtra`](https://cran.r-project.org){.external target="_blank"}   | `r packageVersion("gridExtra")`   | `grid.arrange`          | yes   | no    |
| [`gtable`](https://cran.r-project.org){.external target="_blank"}    | `r packageVersion("gtable")`    | `multi_panel_figure`    | yes   | yes   |
| [`cowplot`](https://cran.r-project.org){.external target="_blank"}   | `r packageVersion("cowplot")`   | `plot_grid`             | yes\* | yes\* |
| [`multipanelfigure`](https://cran.r-project.org){.external target="_blank"}    | `r packageVersion("multipanelfigure")` | `multi_panel_figure`    | yes   | yes   |
| [`egg`](https://cran.r-project.org/web/packages/egg/vignettes/Overview.html){.external target="_blank"}   | `r packageVersion("egg")`              | `ggarrange`             | yes   | yes   |
| [`patchwork`](https://cran.r-project.org){.external target="_blank"}   | `r packageVersion("patchwork")`        | `plot_layout`           | yes   | yes   |

::: {.p style="margin: 1em"}
 
:::

First I'm going to set up a dummy plot that will act as our tester going forward. I'm deliberately going to make it pretty complex to make sure I can demonstrate all the features we might want. I'll be using data from the Bureau of Meteorology that I downloaded and cleaned up. The data I used is available [here](resources/melbourne_weather_times.csv), and if you want to generate a similar dataset the code I used is [here](/resources/code-to-clean-weather-data.R).
```{r}
#| include: false
#| file: ../resources/code-to-clean-weather-data.r
```

```{r default plot}
p.temp.9am = 
  ggplot(data = subset(weather.times, Time == "Morning"), 
         aes(x = Date, y = Temp.C, color = WindDir, shape = Time)) +
  geom_point() + 
  scale_x_date(name = "Month", date_labels = "%b") +
  theme_classic() + theme(legend.position = "none")

p.temp.3pm = 
  ggplot(data = subset(weather.times, Time == "Morning"), 
         aes(x = Date, y = Temp.C, color = WindDir, shape = Time)) +
  geom_point() + 
  scale_x_date(name = "Month", date_labels = "%b") +
  theme_classic() + theme(legend.position = "none")
```

## Basics

Laying two plots out, side by side, is easy with basically any of these packages. The most basic way is probably with the confusingly named custom function `multiplot`, which is built in base packages and defined in [R Cookbook](http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/){.external target="_blank"}.
```{r multiplot function}
#| eval: TRUE
#| include: FALSE
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

```{r grid multiplot}
#| eval: TRUE
#| fig-asp: 0.5

multiplot(p.temp.9am, p.temp.3pm, cols = 2)
```

You can also achieve the same thing with functions already built into the packages `gridExtra`, `ggpubr` and `egg`, which are built on top of the basic `grid` package:
```{r text size}
#| include: FALSE

p.temp.9am = p.temp.9am + theme(text = element_text(size = 16))
p.temp.3pm = p.temp.3pm + theme(text = element_text(size = 16))
```


::: d-grid
::: {.row style="display:flex; width:100%;"}
::: col
#### gridExtra
```{r basic gridExtra}
#| fig-asp: 1.25

gridExtra::grid.arrange(
  p.temp.9am, p.temp.3pm, 
  nrow = 2)
```
:::
::: col
#### ggpubr
```{r basic ggpubr}
#| fig-asp: 1.25

ggpubr::ggarrange(
  p.temp.9am, p.temp.3pm, 
  nrow = 2)
```
:::
::: col
#### egg
```{r basic egg}
#| fig-asp: 1.25

egg::ggarrange(
  p.temp.9am, p.temp.3pm, 
  nrow = 2)
```
:::
:::
:::

However, have a look at the figures above. Doesn't it bother you that the axis titles, labels and tick-marks are repeated over multiple figures? It bothers me. 
It especially bothers me when I'm trying to squeeze a lot of information into one page. Repeated information isn't just redundant, it's actively detrimental to your audience's understanding of your data. Personally, if I was going to plot those two figures together in a paper, I would remove their common axis (y if they're side-by-side, x if they're stacked). 

## Adjustments for subfigures

The simplest way to do achieve this is to remove the offending elements from the plots themselves. I like to do this with theme environment shortcuts, which take advantage of `ggplot2`'s modular structure and can make your code a lot less verbose. For example:
```{r text size 2}
#| include: FALSE

p.temp.9am = p.temp.9am + theme(text = element_text(size = 12))
p.temp.3pm = p.temp.3pm + theme(text = element_text(size = 12))
```

```{r no axes}
#| eval: TRUE 
#| fig-height: 4

no.x = theme(axis.title.x = element_blank(), axis.text.x = element_blank())
no.y = theme(axis.title.y = element_blank(), axis.text.y = element_blank())
```

You can then plot your figures much more neatly, and you'll get exactly the same results using `gridExtra::grid.arrange` and `ggpubr::ggarrange`. However, you'll get a different result when you use `egg::ggarrange`, and in fact `egg::ggarrange` is slightly superior in this regard. It might be easier to see if we switch away from the actual plot and look at the "bones":

```{r boneplot}
lemme_see_dem_bones = function(plot){
  bonegrob = egg::expose_layout(plot, draw = F)
  boneplot = ggpubr::as_ggplot(bonegrob)
  return(boneplot)
}

# Functions ggpubr::as_ggplot() ggplotify::as.ggplot()
```

`expose_layout` allows you to see how the different plot elements are being parsed by whatever package you're using. 

::: d-grid
::: {.row style="display:flex; width:100%;"}
#### gridExtra
::: col
```{r basic gridExtra 2}
#| fig-asp: 1.25

gridExtra::grid.arrange(
  p.temp.9am + no.x, 
  p.temp.3pm, 
  nrow = 2)
```
:::

::: col
```{r basic gridExtra bones}
#| fig-asp: 1.25

gridExtra::grid.arrange(
  lemme_see_dem_bones(p.temp.9am + no.x), 
  lemme_see_dem_bones(p.temp.3pm), 
  nrow = 2)
```
:::

:::

::: {.row style="display:flex; width:100%;"}

#### ggpubr
::: col
```{r basic ggpubr 2}
#| fig-asp: 1.25

ggpubr::ggarrange(
  p.temp.9am + no.x, 
  p.temp.3pm, 
  nrow = 2)
```
:::

::: col
```{r basic ggpubr bones}
#| fig-asp: 1.25

ggpubr::ggarrange(
  lemme_see_dem_bones(p.temp.9am + no.x), 
  lemme_see_dem_bones(p.temp.3pm), 
  nrow = 2)
```
:::

:::

::: {.row style="display:flex; width:100%;"}
#### egg
::: col
```{r basic egg 2}
#| fig-asp: 1.25

egg::ggarrange(
  p.temp.9am + no.x, 
  p.temp.3pm, 
  nrow = 2)
```
:::

::: col
```{r basic egg bones}
#| eval: false
#| fig-asp: 1.25

eg = egg::ggarrange(
  p.temp.9am + no.x, 
  p.temp.3pm, 
  nrow = 2)

expose_layout(eg)
```
:::
:::
:::

You might have already noticed some problems with this approach. For one thing, it's pretty finicky and a bit of a time-trap. You're essentially manually removing bits of each plot to fit the image in your head, and before you know it you'll have spent 6 hours trying to get a figure to look right. 
For another, the sub-figures above are actually slightly different sizes. The axes titles take up part of the plot area allotted to each sub-figure, so removing them causes the rest of the plot area to expand to fill it. Not ideal.

Even worse, it's standard practice to label subfigures within the plot area. 
grid.arrange is a little too simple function, but the two `ggarrange` functions (in `egg` and `ggpubr`) will do it for you pretty easily. However, they are not flexible about where those labels are placed within the plot area, and this is especially obvious when illustrating with a 4-panel figure:
```{r text size 4}
#| include: FALSE

p.temp.9am = p.temp.9am + theme(text = element_text(size = 12))
p.temp.3pm = p.temp.3pm + theme(text = element_text(size = 12))
```

```{r 4 panels with labels}
#| fig-width: 10
#| fig-height: 8

# WH = c(4, 3)

# egg::ggarrange(
#   ggplotify::as.ggplot(
#     egg::set_panel_size(p.temp.9am + no.x, width = unit(WH[1], "in"), height = unit(WH[2], "in"))
#     ),
#   ggplotify::as.ggplot(
#     egg::set_panel_size(p.temp.9am + no.x + no.y, width = unit(WH[1], "in"), height = unit(WH[2], "in"))
#     ),
#   ggplotify::as.ggplot(
#     egg::set_panel_size(p.temp.3pm, width = unit(WH[1], "in"), height = unit(WH[2], "in"))
#     ),
#   ggplotify::as.ggplot(
#     egg::set_panel_size(p.temp.3pm + no.y, width = unit(WH[1], "in"), height = unit(WH[2], "in"))
#     ),
#   nrow = 2, ncol = 2, labels = c("A", "B", "C", "D"))

geg = egg::ggarrange(p.temp.9am + no.x, 
               p.temp.9am + no.x + no.y, 
               p.temp.3pm, 
               p.temp.3pm + no.y, 
               ncol = 2, nrow = 2,
               widths = c(1, 1), heights = c(1, 1), 
               labels = c("A", "B", "C", "D"),
               debug= T,
               label.args = list(gp = gpar(fontfamily = "sans", fontsize = 12, fontface = "bold"), x = unit(1, "null")), 
               draw = T)
```
Ew.


```{r gtable}
#| eval: FALSE

gtab = gtable_matrix(name = NULL,
                     grobs = matrix(list(grob.1, grob.1), nrow = 1), 
                     widths = unit(c(1, 1), "null"), 
                     heights = unit(1, "null"))

g1 = expose_layout(dummy.1) 

gtab = gtable_matrix(name = NULL, 
                     grobs = matrix(list(g1, g1), nrow = 1), 
                     widths = unit(c(1, 1), "null"), 
                     heights = unit(1, "null"))

grid.draw(gtab)
```


# grob.1 = ggplotGrob(p.temp.9am) # Default plot as a grob

## Create ggplot from grob

```{r}
#| eval: FALSE

ggplotify::as.ggplot(g1)

egg::ggarrange(ggplotify::as.ggplot(g1), ggplotify::as.ggplot(g1), nrow = 1)
```

## The `r 'egg'` package

```{r}
#| eval: FALSE

# https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html

layout_matrix = rbind(c(1, 2, 3), c(1, 4, 4))

egg::ggarrange(ggplot(), ggplot(), ggplot(), ggplot(), 
               # ncol = 3, nrow = 2, 
               widths = c(1, 1, 1, 2), heights = c(2, 1, 1, 1), 
               labels = c("A", "B", "C", "D"),
               label.args = list(gp = gpar(fontfamily = "sans", 
                                           fontsize = 12, fontface = "bold"), 
                                 x = unit(1.95, "cm"), vjust = 1, hjust = 1), 
               draw = T)

g1 = gtable_frame(ggplotGrob(ggplot()), width = unit(1, "null"), height = unit(2, "null"), debug = TRUE)
g2 = gtable_frame(ggplotGrob(ggplot()), width = unit(1, "null"), height = unit(1, "null"), debug = TRUE)
g3 = gtable_frame(ggplotGrob(ggplot()), width = unit(1, "null"), height = unit(1, "null"), debug = TRUE)
g4 = gtable_frame(ggplotGrob(ggplot()), width = unit(2, "null"), height = unit(1, "null"), debug = TRUE)

g23 = gtable_frame(gtable_cbind(gtable_frame(ggplotGrob(ggplot())), 
                                gtable_frame(ggplotGrob(ggplot()))), 
                   width = unit(2, "null"), height = unit(1, "null"))
g234 = gtable_frame(gtable_rbind(g23, 
                                 gtable_frame(ggplotGrob(ggplot()))), 
                    width = unit(2, "null"), height = unit(2, "null"))
gcomb = gtable_frame(gtable_cbind(gtable_frame(ggplotGrob(ggplot())),
                                  g234),
                     width = unit(3, "null"), height = unit(2, "null"))

grid.newpage()
grid.draw(gcomb)
```

